<html>
<body>
<script>
	// 27 March 2017
	// Simple implementation of page curl effect interaction

	// TODO make random pinches and flips

	const BOOK_WIDTH = 200;
	const BOOK_HEIGHT = 300;

	const canvas = document.createElement('canvas');
	canvas.width = BOOK_WIDTH * 3;
	canvas.height = BOOK_HEIGHT * 2;

	document.body.appendChild(canvas);

	const ctx = canvas.getContext('2d');

	const book = {
		x: (canvas.width - BOOK_WIDTH) * 0.85,
		y: (canvas.height - BOOK_HEIGHT) * 0.5,
	};

	book.x2 = book.x + BOOK_WIDTH;
	book.y2 = book.y + BOOK_HEIGHT;

	const mouse = { x: 0, y: 0 };
	let mousedown = null;

	// Setup handlers

	canvas.addEventListener('mousemove', e => {
		mouse.x = e.offsetX;
		mouse.y = e.offsetY;
	});

	canvas.addEventListener('mousedown', e => {
		mouse.x = e.offsetX;
		mouse.y = e.offsetY;

		if (gripEdge()) {
			mousedown = Object.assign({}, mouse);
		}
	});

	canvas.addEventListener('mouseup', e => {
		mousedown = null;
	});

	// Functions

	class Vector {
		constructor(x, y) {
			this.x = x;
			this.y = y;
		}

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}

		unit() {
			const l = this.length();
			return new Vector(this.x / l, this.y / l);
		}

		mul(l) {
			return new Vector(this.x * l, this.y * l);
		}

		add(v) {
			return new Vector(this.x + v.x, this.y + v.y);
		}

		sub(v) {
			return new Vector(this.x - v.x, this.y - v.y);
		}

	}

	function gripEdge() {
		const dx = book.x2 - mouse.x;
		return dx >= 0 && dx < 15
	}

	function circle(x, y, r=10) {
		ctx.beginPath();
		ctx.arc(x, y, r, 0, Math.PI * 2);
		ctx.fill();
	}

	function lineVec(a, b) {
		line(a.x, a.y, b.x, b.y);
	}
	function line(x0, y0, x1, y1) {
		ctx.beginPath();
		ctx.moveTo(x0, y0);
		ctx.lineTo(x1, y1);
		ctx.stroke();
	}

	function project(unit, reference, len = 50) {
		const normal = new Vector(-unit.y, unit.x);
		const pinch = mousedown.y - book.y;
		const pinch2 = book.y2 - mousedown.y;

		let corner1 = normal.mul(-pinch).add(reference);
		let corner2 = normal.mul(pinch2).add(reference);

		ctx.save();

		ctx.strokeStyle = '#999';
		const guide1 = unit.mul(len);
		const guide2 = unit.mul(len);
		// line(corner1.x, corner1.y, corner1.x + guide1.x, corner1.y + guide1.y);
		// line(corner2.x, corner2.y, corner2.x + guide2.x, corner2.y + guide2.y);

		// corner1 to find intersection with book Edges

		// sanity checks - Corners must be < book.x2
		// unit.mul(x).add(corner1).y = book.y
		// unit.y * x + corner1.y = book.y
		// unit.y * x = book.y - corner1.y
		// x = (book.y - corner1.y) / unit.y

		if (unit.y === 0) {
			return line(corner1.x + guide1.x, corner1.y + guide1.y, corner2.x + guide2.x, corner2.y + guide2.y);
		}

		ctx.strokeStyle = 'black';

		let lenTop = (book.y - corner1.y) / unit.y;
		let guideTop = unit.mul(lenTop).add(corner1);

		let lenBottom = (book.y2 - corner2.y) / unit.y;
		let guideBottom = unit.mul(lenBottom).add(corner2);

		if (corner1.x > guideTop.x) {
			if (corner1.x > book.x2) {
				lenTop = (book.x2 - corner1.x) / normal.x;
				guideTop = normal.mul(lenTop).add(corner1);
				// circle(guideTop.x, guideTop.y)
				corner1 = guideTop;
			} else
			corner1 = guideTop;
		} else if (corner2.x > book.x2) {
			lenTop = (book.x2 - corner2.x) / normal.x;
			guideBottom = normal.mul(lenTop).add(corner2);
			// circle(guideBottom.x, guideBottom.y)
			corner2 = guideBottom;
		}

		lineVec(corner1, guideTop);
		lineVec(corner2, guideBottom);
		lineVec(guideBottom, guideTop);

		ctx.fillStyle = 'blue';
		circle(corner1.x, corner1.y);

		ctx.fillStyle = 'blue';
		circle(corner2.x, corner2.y);

		ctx.strokeStyle = 'black';
		lineVec(corner1, corner2);

		ctx.restore();
	}

	function handleDrag() {
		if (mousedown) {
			// ctx.strokeStyle = '#999';
			// line(mousedown.x, mousedown.y, mouse.x, mouse.y);

			/*
			const midX = (mousedown.x + mouse.x) * 0.5
			const midY = (mousedown.y + mouse.y) * 0.5
			const mid = new Vector(midX, midY);
			*/

			// ctx.fillStyle = 'green';
			// circle(midX, midY, 5);

			ctx.fillStyle = 'red';
			circle(mousedown.x, mousedown.y);

			ctx.fillStyle = 'yellow';
			circle(mouse.x, mouse.y);

			const dx = mousedown.x - mouse.x;
			const dy = mousedown.y - mouse.y;

			if (dx < 0) return;

			// const unit = new Vector(dx, dy).unit();
			// unit.y *= 2;
			// project(unit, mouse, new Vector(dx, dy).length());

			// ctx.strokeStyle = '#bbb';
			// line(mousedown.x, mousedown.y, book.x, mousedown.y);

			// Seems like an approximation right now
			let rd = new Vector(dx, dy).length();
			// rd = Math.sqrt((rd * rd) / 2)
			rd /= 2;

			ctx.strokeStyle = 'black';
			const crease = book.x2 - rd;
			const creasePoint = new Vector(crease, mousedown.y);

			// ctx.fillStyle = 'purple';
			// circle(creasePoint.x, creasePoint.y);
			// //  crease point line
			// line(creasePoint.x, creasePoint.y, mouse.x, mouse.y);

			const unit2 = creasePoint.sub(mouse).unit();
			project(unit2, mouse, creasePoint.sub(mouse).length());

			// debug parrell crease
			// ctx.strokeStyle = '#999';
			// line(crease, book.y, crease, book.y2);

			// could run an iterative solver

		}
	}

	function render() {
		ctx.clearRect(0, 0, canvas.width, canvas.height);

		handleDrag();

		if (gripEdge()) {
			ctx.fillStyle = 'red';
			circle(mouse.x, mouse.y);
		}

		ctx.strokeStyle = '#bbb';
		ctx.beginPath();
		ctx.rect(book.x, book.y, BOOK_WIDTH, BOOK_HEIGHT);
		ctx.stroke();

		requestAnimationFrame(render);
	}

	render();
</script>
</body>
</html>
