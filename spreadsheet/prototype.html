<html>

<body>
	<pre>Simple spreadsheet</pre>
	<div><input id="editor" /></div>
	<div id="spread" style="position:relative; display:block;"></div>
	<div style="position:absolute; bottom:0px;">
		<pre id="status_bar"></pre>
	</div>

	<script>
		var rows = 20;
		var cols = 20;

		var cell_width = 50;
		var cell_height = 20;

		var cells = new Map();

		var referencing = null;
		var editing = null;

		editor.onkeydown = update_field.bind(editor)

		class Cell {
			constructor(x, y) {
				this.x = x;
				this.row = String.fromCharCode('A'.charCodeAt(0) + x);
				this.col = y;
				this.name = this.row + this.col;

				let dom = document.createElement('input');
				dom.type = 'text';
				dom.style.position = "absolute";
				dom.style.width = `${cell_width}px`;
				dom.style.height = `${cell_height}px`;
				dom.style.left = `${x * cell_width}px`;
				dom.style.top = `${y * cell_height}px`;
				dom.id = this.name;
				dom.onclick = (e) => {
					document.getElementById('status_bar').innerHTML = dom.id;
					console.log(editing);

					if (referencing) {
						e.preventDefault();

						editor.value += ' ' + this.name;
						editor.focus();

						referencing = null;
						return false;
					}

					editing = this;
					editor.focus();

					editor.value = dom.value;
				}
				dom.onkeydown = (e) => {
					editing = this;

					console.log(e.code);

				}

				this.dom = dom;

				spread.appendChild(dom);
			}

			update_content(content) {
				this.content = content;

				this.update_cell();
			}

			update_cell() {
				var content = this.content;
				if (!isFormula(content)) {
					this.dom.value = content;
				}

				var expressions = parseExpression(content);

				// otherwise calculate formula
			}

			// todo PARSE formulas = 

		}

		for (let y = 0; y < rows; y++) {
			for (let x = 0; x < cols; x++) {
				let cell = new Cell(x, y);
				cells.set(cell.name, cell);
			}
		}

		function update_field(e) {
			if (editing) {
				console.log(editor.value, e.code);
				if (editor.value.startsWith('=') || e.code == 'Equal') {
					referencing = true;
				}

				if (e.code == 'Enter') {
					// || e.code == 'Escape') {
					editing.value = editor.value;
					editing.update_content(editor.value)

					editor.value = '';
					editor.blur();

					console.log('enter')
					editing = null;
				}
			}
		}

		/* Parsing */

		function isFormula(str) {
			return str.startsWith('=');
		}

		var ref_regex = /([A-Z]+)([0-9]+)/;
		function isRef(str) {
			return ref_regex.exec(str)
		}

		function isOperator(str) {
			return /[\*+-\/]/.exec(str);
		}

		function parseExpression(str) {
			var tokens = str.split(/\s+/);

			var expression = [];

			tokens.forEach(token => {
				if (isFormula(token)) {
					expression.push(['formula', token]);
				}
				else if (isRef(token)) {
					expression.push(['ref', token]);
				}
				else if (isOperator(token)) {
					expression.push(['operator', token]);
				}
				else {
					expression.push(['value', token]);
				}
			});

			return expression;
		}

		class ValExpr {
			constructor(value) {
				this.value = value;
			}
		}
		class SumExpr {
			constructor(left, right, op) {
				this.left = left;
				this.right = right;
				this.op = op;
			}
		}


		class Evaluator {
			constructor(expressions) {
				this.expressions = expressions;
				this.position = -1;
			}

			peek() {
				return this.expressions[this.position + 1];
			}

			consume() {
				return this.expressions[++this.position];
			}

			ended() {
				return this.position >= this.expressions.length - 1;
			}

			run() {
				var expr;
				while (!this.ended()) {
					let [t, token] = this.peek();
					console.log('--', t, token)

					if (t == 'formula') {
						this.consume();
					} else if (t == 'ref') {
						return console.log('not supported yet!');
					} else {
						expr = this.nextExpression();
					}
				}

				return expr;
			}

			nextExpression() {
				console.log('nextExpression', this.position);
				let expr;
				while (!this.ended()) {
					let [t, token] = this.peek();

					if (t == 'value') {
						this.consume();
						expr = new ValExpr(token);
					} else if (t == 'operator') {
						let [t, token] = this.consume();
						if (!expr) {
							console.error('operator with expression!')
						}

						expr = new SumExpr(expr, this.nextExpression(), token);
					} else {
						console.error('unhandled', t, token)
					}
				}
				return expr;
			}
		}

		function evaluateExpression(expressions) {
			var e = new Evaluator(expressions);
		}
		/**
		 * Test cases
		 * isFormula/isValue
		 * parseFormular * () / 
		 * dependencyTree
		 */

		console.assert(isFormula('= A1 + A2'))
		console.assert(!isFormula('12345'))
		console.assert(!isFormula('abcdefghs'))

		console.assert(isRef('A1'));
		console.assert(isRef('AA100'));
		console.assert(!isRef('1'));
		console.assert(!isRef('AAA'));

		console.assert(isOperator('+'));
		console.assert(isOperator('-'));
		console.assert(isOperator('*'));
		console.assert(isOperator('/'));

		var expressions = parseExpression('= A1 + A2 + 5');
		var expressions = parseExpression('= 1 + 2 + 3 + 4 + 5');

		console.log('expressions', expressions);

		var evaluator = new Evaluator(expressions);

		console.log('evaluator', evaluator.run());


	</script>
</body>

</html>